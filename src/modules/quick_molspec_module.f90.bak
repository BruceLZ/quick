!
!	quick_molspec_module.f90
!	new_quick
!
!	Created by Yipu Miao on 2/18/11.
!	Copyright 2011 University of Florida. All rights reserved.
!

!********************************************************
! molecule specification Module
!--------------------------------------------------------
!
    module quick_molspec_module
    implicit none
    ! molchg :  total molecular charge
    ! chg    :  Atom Charge
    ! extchg :  External Charges
    ! nextatom: No. of External Charges
    ! nelec  :  No. of Electrons or Alpha Electrons
    ! nelecb :  No. of Beta Electrons
    ! nNonHATOM: No. of Non-H Atoms
    ! NHAtom :  No. of H Atoms
    ! natom  :  No. of totoal Atoms
    ! xyz    :  Coordinates
    ! extxyz :  Coordinates of external charges
    ! AtomDistance: Atom Distance Matrix
    type quick_molspec_type
    
        ! number of atoms
        integer :: natom = 0
        
        ! number of electron and beta electron
        integer :: nElec = 0 
        integer :: nElecb = 0
        
        ! number of external atoms
        integer :: nExtAtom = 0
        
        ! multiplicity
        integer :: imult = 1
        
        ! molecular charge
        integer :: molchg = 0
        
        ! number of non-hydrogen atom
        integer :: nNonHAtom = 0
        
        ! number of hydrogen atom
        integer :: nHAtom = 0
        
        ! number of atom types
        integer :: iAtomType = 0
        
        ! symbol for respective atom type
        character(len=2), dimension(1:10) :: atom_type_sym
        
        ! distantce to the nearest atom
        double precision, dimension(:), allocatable :: distnbor
        
        ! distance matrix
        double precision, dimension(:,:), allocatable :: AtomDistance
        
        ! coordinate of atoms and external atoms
        double precision, dimension(:,:), allocatable :: xyz,extxyz
        
        ! which atom type id every atom crosponds to 
        integer,dimension(:),allocatable :: iattype
        
        ! atom charge and external atom charge
        double precision, dimension(:), allocatable ::chg,extchg
        
    end type quick_molspec_type
    
    type (quick_molspec_type) quick_molspec
    
    
    ! interface lists
    
    interface print
        module procedure print_quick_molspec
    end interface print
    
    interface alloc
        module procedure allocate_quick_molspec
    end interface alloc
    
    interface init
        module procedure init_quick_molspec
    end interface init
    
    interface read
        module procedure read_quick_molspec
    end interface read
    
    interface read2
        module procedure read_quick_molspec_2
    end interface read2
            
    interface dealloc
        module procedure deallocate_quick_molspec
    end interface dealloc
    
    interface set
        module procedure set_quick_molspec
    end interface set
    
    
    
    
    double precision, dimension(:,:), allocatable :: xyz, extxyz, AtomDistance ! to be sub


    integer, dimension(:), allocatable :: iattype
    double precision,dimension(:),allocatable::Mulliken,Lowdin  ! to be sub
    double precision, dimension(:), allocatable :: chg,extchg,distnbor ! to be sub

    integer :: molchg   ! to be sub
    integer :: natom,nelec,nelecb,nextatom,imult,nNonHAtom,nHAtom  ! to be sub
    integer :: iatomtype    ! to be sub
    character(len=2), dimension(1:10) :: atom_type_sym  ! to be sub
    
    
    contains
    
    !-------------------
    ! allocate
    !-------------------
    subroutine allocate_quick_molspec(self)
        implicit none
        integer i,j
        
        type (quick_molspec_type) self
        
        allocate(self%distnbor(self%natom))
        allocate(self%xyz(3,self%natom))
        allocate(self%iattype(self%natom))
        allocate(self%chg(self%natom))
        allocate(self%AtomDistance(self%natom,self%natom))
        
        do i=1,self%natom
            self%distnbor(i)=0
            self%iattype(i)=0
            self%chg(i)=0d0
            do j=1,3
                self%xyz(j,i)=0d0
            enddo
            do j=1,self%natom
                self%AtomDistance(i,j)=0d0
            enddo
        enddo
        
        ! if exist external charge
        if (self%nextatom.gt.0) then
            allocate(self%extxyz(3, self%nextatom))
            allocate(self%extchg(self%nextatom))
            do i=1,self%nextatom
                do j=1,3
                    self%extxyz(j,i)=0d0
                enddo
                self%extchg(i)=0d0
            enddo
        endif
        
    
    end subroutine allocate_quick_molspec
    
    !-------------------
    ! set initial value
    !-------------------
    subroutine init_quick_molspec(self)
        implicit none
        
        type (quick_molspec_type) self

        self%natom = 0
        self%nElec = 0 
        self%nElecb = 0
        self%nExtAtom = 0
        self%imult = 1
        self%molchg = 0
        self%nNonHAtom = 0
        self%nHAtom = 0
        self%iAtomType = 0
        
    
    end subroutine init_quick_molspec

    !-------------------
    ! deallocate
    !-------------------
    subroutine deallocate_quick_molspec(self)
        implicit none
        
        type (quick_molspec_type) self
        
        deallocate(self%distnbor)
        deallocate(self%xyz)
        deallocate(self%iattype)
        deallocate(self%chg)
        
        ! if exist external charge
        if (self%nextatom.gt.0) then
            deallocate(self%extxyz)
            deallocate(self%extchg)
        endif
        
    end subroutine deallocate_quick_molspec

    !-------------------
    ! broadcast variable list
    !-------------------
    subroutine broadcast_quick_molspec(self)
        use quick_mpi_module
        implicit none
        include "mpif.h"
        type (quick_molspec_type) self
        integer natom,natom2
        
        call MPI_BARRIER(MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%natom,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        
        natom=self%natom
        natom2=natom**2
        
        call MPI_BCAST(self%nElec,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%nElecb,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%nextatom,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%imult,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%molchg,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%nNonHAtom,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%nHAtom,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%iAtomType,1,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%atom_type_sym,20,mpi_character,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%distnbor,natom,mpi_double_precision,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%AtomDistance,natom2,mpi_double_precision,0,MPI_COMM_WORLD,mpierror)
        call MPI_BCAST(self%xyz,natom*3,mpi_double_precision,0,MPI_COMM_WORLD,mpierror)
        
        if (self%nextatom.gt.0) then
            call MPI_BCAST(self%extxyz,self%nextatom*3,mpi_double_precision,0,MPI_COMM_WORLD,mpierror)
            call MPI_BCAST(self%extchg,self%nextatom,mpi_double_precision,0,MPI_COMM_WORLD,mpierror)
        endif
        call MPI_BCAST(self%iattype,natom,mpi_integer,0,MPI_COMM_WORLD,mpierror)
        
    end subroutine broadcast_quick_molspec

    !----------------------
    ! read molecular specification phase 1
    ! this subroutine is to read charge, multiplicity, and number
    ! and kind of atom.
    !----------------------
    subroutine read_quick_molspec(self,input)
        use quick_constants_module
        implicit none
        type (quick_molspec_type) self
        integer input,rdinml,i,j,k
        integer ierror
        integer iAtomType
        integer natom
        integer nextatom
        double precision temp,rdnml
        character(len=200) keywd
        logical :: is_extcharge = .false.
        logical :: is_blank
        
        
        rewind(input)
        
        !---------------------
        ! PART I
        !---------------------
        ! The first line is Keyword
        read (input,'(A80)') keywd
        call upcase(keywd,200)

        ! Read Charge
        if (index(keywd,'CHARGE=') /= 0) self%molchg = rdinml(keywd,'CHARGE')

        ! read multipilicity
        if (index(keywd,'MULT=') /= 0) self%imult = rdinml(keywd,'MULT')

        ! determine if external charge exists
        if (index(keywd,'EXTCHARGES') /= 0) is_extcharge=.true.
        
        call findBlock(input,1)
        
        ! first is to read atom and atom kind
        iAtomType = 1
        natom = 0
        nextatom = 0
        do
            read(input,'(A80)',end=111,err=111) keywd
            i=1;j=80
            call upcase(keywd,80)
            call rdword(keywd,i,j)
            if (is_blank(keywd,1,80)) exit
            do k=0,71
                if (keywd(i:j) == symbol(k)) then
                    natom=natom+1
                    ! check if atom type has been shown before
                    if (.not.(any(self%atom_type_sym(1:iatomtype).eq.symbol(k)))) then
                        self%atom_type_sym(iAtomType)=symbol(k)
                        iAtomType=iAtomType+1
                    endif
                endif
            enddo
        enddo
        
111     continue

        ! read external charge part
        if (is_extcharge)  then
            call findBlock(input,2)
            do 
                read(input,'(A80)',end=112,err=112) keywd
                call rdword(keywd,i,j)
                if (is_blank(keywd,1,80)) exit
                nextatom=nextatom+1 
            enddo
        endif
        
112     continue

        iAtomType=iAtomType-1
        
        self%natom = natom
        self%iAtomType = iAtomType
        self%nextatom = nextatom
        
    end subroutine read_quick_molspec
    
    subroutine read_quick_molspec_2(self,input)
        use quick_constants_module
        implicit none
        type (quick_molspec_type) self
        integer input,rdinml,i,j,k
        integer ierror
        double precision temp,rdnml
        character(len=200) keywd
        
        
        
        
    end subroutine read_quick_molspec_2
    
    !-------------------
    ! print varibles
    !-------------------
    subroutine print_quick_molspec(self,io)
        use quick_constants_module
        implicit none
        integer io,i,j
        type(quick_molspec_type) self
        if (io.ne.0) then
        write(io,'(/," =========== Molecule Input ==========")')
        write(io,'(" TOTAL MOLECULAR CHARGE  = ",I4,4x,"MULTIPLICITY                = ",I4)') self%molchg,self%imult
        write(io,'(" TOTOAL ATOM NUMBER      = ",i4,4x,"NUMBER OF ATOM TYPES        = ",i4)') self%natom,self%iAtomType
        write(io,'(" NUMBER OF HYDROGEN ATOM = ",i4,4x,"NUMBER OF NON-HYDROGEN ATOM = ",i4)') self%nhatom,self%nNonHAtom

        if (self%nelecb.ne.0) then
            write (io,'(" NUMBER OF ALPHA ELECTRONS = ",I4)') self%nelec
            write (io,'(" NUMBER OF BETA ELECTRONS  = ",I4)') self%nelecb
        else
            write (io,'(" NUMBER OF ELECTRONS     = ",I4)') self%nelec
        endif
        
        write(io,*)
        write(io,'(" -- INPUT GEOMETRY -- :")')
        do I=1,self%natom
            Write (io,'(A2,6x,F10.4,3x,F10.4,3x,F10.4)') &
                symbol(self%iattype(I)),self%xyz(1,I)*bohr,self%xyz(2,I)*bohr,self%xyz(3,I)*bohr
        enddo
        
        if(self%nextatom.gt.0 )then
            write(io,*)
            write(io,'("EXTERNAL POINT CHARGES: (Q,X,Y,Z)")')
            do i=1,self%nextatom
                write(io,'(F7.4,3(F10.4,1x))') self%extchg(i),self%extxyz(:,i)*bohr
            enddo
        endif
    
        ! if no. of atom is less than 30, then output them
        if (self%natom.le.30) then
            write(io,*)
            write(io,'("DISTANCE MATRIX:")')
            call PriSym(io,self%natom,self%atomdistance,'f10.4')
        endif 
        endif
    
    end subroutine print_quick_molspec
    
    !-------------------
    ! set up some varibles
    ! this subroutine is to automatically generate other molspec information from
    ! read-in molespec. 
    !-------------------

    subroutine set_quick_molspec(self)
        implicit none
        integer natom,i,j,k
        type (quick_molspec_type) self
        
        natom=self%natom
        
        ! first set Distance Matrix    
        do i=1,natom
            do j=i,natom
                self%atomdistance(i,j)=0d0
                do k=1,3
                    self%atomdistance(i,j)=self%atomdistance(i,j)+(self%xyz(k,i)-self%xyz(k,j))**2
                enddo
                self%atomdistance(i,j)=sqrt(self%atomdistance(i,j))
            enddo
        enddo
        
        call CopySym(self%atomdistance,natom)

        ! second set distnbor
        do i=1,natom
            self%distnbor(i)=1.D30
            do j=1,natom
                if (j.ne.i) then
                    self%distnbor(i)=Min(self%distnbor(i),self%atomdistance(i,j))
                endif
            enddo
        enddo


        ! get and return no. of hydrogen atom and non-hydogren
        j=0
        do i=1,natom
            if (self%iattype(I).eq.1) j=j+1
        enddo
        self%nHAtom=j
        self%nNonHAtom=natom-j
    
    end subroutine set_quick_molspec

    end module quick_molspec_module
!********************************************************